#分词器介绍：把小说按照每{每次分词字数}字数分割，如果不是{分割的符号}那它就会往前找
#输入：srting 输出：array
def 分词器(data):
    每次分词字数 = 200
    处理到的分词位置 = 每次分词字数
    分割的符号 = [".", "。", "!", "！", "?", "？"]
    分割下一位符号 = ['"', "”", "“"]
    上次处理位置 = 1
    循环次数 = 1
    内容 = []
    while True:
        if not 处理到的分词位置 >= len(data):
            if not data[处理到的分词位置] in 分割的符号:
                if 处理到的分词位置 <= 上次处理位置:
                    循环次数 += 1
                    处理到的分词位置 = 上次处理位置 + 每次分词字数 * 循环次数
                else:
                    处理到的分词位置 -= 1
            else:
                if data[处理到的分词位置+1] in 分割下一位符号:
                    待处理的字符 = data[上次处理位置-1:处理到的分词位置+2]
                    上次处理位置 = 处理到的分词位置 + 3
                    处理到的分词位置
                else:
                    待处理的字符 = data[上次处理位置-1:处理到的分词位置+1]
                    上次处理位置 = 处理到的分词位置 + 2
                处理到的分词位置 = 上次处理位置 + 每次分词字数
                循环次数 = 1
                内容.append(待处理的字符)
        else:
            待处理的字符 = data[上次处理位置:len(data)]
            内容.append(待处理的字符)
            return 内容

#精度损失：3.05‱
#仅支持向量
def F32编码F16_S1E2M13(输入数组): #Qwen3-Max编写
    输入数组 = np.asarray(输入数组, dtype=np.float32)
    缩放后数组 = 输入数组 / 50
    符号位 = np.signbit(缩放后数组).astype(np.uint16) << 15
    绝对值数组 = np.abs(缩放后数组)
    是否为零 = 绝对值数组 < 1e-20
    是否为次正规数 = (绝对值数组 > 0) & (绝对值数组 < 1.0)
    次正规尾数 = (绝对值数组 * 8192).astype(np.uint16)
    次正规尾数 = np.clip(次正规尾数, 0, 8191)
    是否为正规数 = 绝对值数组 >= 1.0
    原始指数 = np.floor(np.log2(np.maximum(绝对值数组[是否为正规数], 1e-38))).astype(np.int32)
    偏置后指数 = np.clip(原始指数 + 1, 1, 3)
    正规尾数 = np.zeros_like(绝对值数组, dtype=np.uint16)
    正规尾数[是否为正规数] = (
        (绝对值数组[是否为正规数] / (2.0 ** 原始指数) - 1.0) * 8192
    ).astype(np.uint16)
    正规尾数 = np.clip(正规尾数, 0, 8191)
    指数字段 = np.zeros_like(绝对值数组, dtype=np.uint16)
    指数字段[是否为正规数] = 偏置后指数
    编码结果 = 符号位 | (指数字段.astype(np.uint16) << 13) | \
              np.where(是否为次正规数, 次正规尾数, 正规尾数)
    编码结果[是否为零] = 0
    return 编码结果.astype(np.uint16)
def F16_S1E2M13解码F32(编码数组): #Qwen3-Max编写
    编码数组 = np.asarray(编码数组, dtype=np.uint16)
    符号位 = (编码数组 >> 15) & 0x1
    指数字段 = (编码数组 >> 13) & 0x3
    尾数部分 = 编码数组 & 0x1FFF
    解码值 = np.zeros_like(编码数组, dtype=np.float32)
    是否为次正规数 = 指数字段 == 0
    解码值[是否为次正规数] = 尾数部分[是否为次正规数].astype(np.float32) * (2.0 ** -13)
    是否为正规数 = 指数字段 > 0
    无偏指数 = 指数字段[是否为正规数].astype(np.int32) - 1
    解码值[是否为正规数] = (1.0 + 尾数部分[是否为正规数] / 8192.0) * (2.0 ** 无偏指数)
    解码值[符号位 == 1] *= -1.0
    return (解码值 * 5.0).astype(np.float32)

#精度损失：1.55939-2.33255·e^(-0.48921·块大小)
#1.03014824484466% Q8块大小3 13.33位
#1.22334327776861% Q8块大小4 12.00位
#1.33873242763635% Q8块大小5 11.20位
#1.42752140332602% Q8块大小6 10.67位
#1.55683082151632% Q8块大小8 10.00位
#1.55891542483511% Q8块大小10 9.60位
#1.55754342907996% Q8块大小12 9.33位
#1.55652295469636% Q8块大小16 9.00位（Q8_0）
#1.55355223017866% Q8块大小32 8.50位
#1.56134002633492% Q8块大小256 8.0625位（Q8_K）
#仅支持向量
def F32编码Q8(输入数组, 块大小=32): #Qwen3-Max编写
    输入数组 = np.asarray(输入数组, dtype=np.float32)
    原始形状 = 输入数组.shape
    扁平化 = 输入数组.flatten()
    填充长度 = (-len(扁平化)) % 块大小
    填充后数组 = np.pad(扁平化, (0, 填充长度), mode='constant')
    块数量 = len(填充后数组) // 块大小
    量化结果 = np.zeros(块数量 * 块大小, dtype=np.int8)
    缩放因子列表 = np.zeros(块数量, dtype=np.float16)
    for i in range(块数量):
        当前块 = 填充后数组[i*块大小:(i+1)*块大小]
        当前块最大绝对值 = np.abs(当前块).max()
        缩放因子 = (当前块最大绝对值 / 127.0) if 当前块最大绝对值 > 1e-8 else 1.0
        缩放因子列表[i] = 缩放因子.astype(np.float16)
        量化块 = np.clip(np.round(当前块 / 缩放因子), -127, 127).astype(np.int8)
        量化结果[i*块大小:(i+1)*块大小] = 量化块
    量化结果 = 量化结果[:len(扁平化)]
    return 量化结果.reshape(原始形状), 缩放因子列表
def Q8解码F32(量化数据, 缩放因子列表, 块大小=32): #Qwen3-Max编写
    量化数据 = np.asarray(量化数据, dtype=np.int8)
    原始形状 = 量化数据.shape
    扁平化量化 = 量化数据.flatten()
    填充长度 = (-len(扁平化量化)) % 块大小
    填充后量化 = np.pad(扁平化量化, (0, 填充长度), mode='constant')
    块数量 = len(填充后量化) // 块大小
    反量化结果 = np.zeros_like(填充后量化, dtype=np.float32)
    for i in range(块数量):
        当前量化块 = 填充后量化[i*块大小:(i+1)*块大小]
        反量化结果[i*块大小:(i+1)*块大小] = 当前量化块.astype(np.float32) * 缩放因子列表[i]
    return 反量化结果[:len(扁平化量化)].reshape(原始形状)
