#分词器介绍：把小说按照每{每次分词字数}字数分割，如果不是{分割的符号}那它就会往前找
#输入：srting 输出：array
def 分词器(data):
    每次分词字数 = 200
    处理到的分词位置 = 每次分词字数
    分割的符号 = [".", "。", "!", "！", "?", "？"]
    分割下一位符号 = ['"', "”", "“"]
    上次处理位置 = 1
    循环次数 = 1
    内容 = []
    while True:
        if not 处理到的分词位置 >= len(data):
            if not data[处理到的分词位置] in 分割的符号:
                if 处理到的分词位置 <= 上次处理位置:
                    循环次数 += 1
                    处理到的分词位置 = 上次处理位置 + 每次分词字数 * 循环次数
                else:
                    处理到的分词位置 -= 1
            else:
                if data[处理到的分词位置+1] in 分割下一位符号:
                    待处理的字符 = data[上次处理位置-1:处理到的分词位置+2]
                    上次处理位置 = 处理到的分词位置 + 3
                    处理到的分词位置
                else:
                    待处理的字符 = data[上次处理位置-1:处理到的分词位置+1]
                    上次处理位置 = 处理到的分词位置 + 2
                处理到的分词位置 = 上次处理位置 + 每次分词字数
                循环次数 = 1
                内容.append(待处理的字符)
        else:
            待处理的字符 = data[上次处理位置:len(data)]
            内容.append(待处理的字符)
            return 内容


def F32编码F16_S1E2M13(输入数组): #Qwen3-Max编写
    输入数组 = np.asarray(输入数组, dtype=np.float32)
    缩放后数组 = 输入数组 / 50
    符号位 = np.signbit(缩放后数组).astype(np.uint16) << 15
    绝对值数组 = np.abs(缩放后数组)
    是否为零 = 绝对值数组 < 1e-20
    是否为次正规数 = (绝对值数组 > 0) & (绝对值数组 < 1.0)
    次正规尾数 = (绝对值数组 * 8192).astype(np.uint16)
    次正规尾数 = np.clip(次正规尾数, 0, 8191)
    是否为正规数 = 绝对值数组 >= 1.0
    原始指数 = np.floor(np.log2(np.maximum(绝对值数组[是否为正规数], 1e-38))).astype(np.int32)
    偏置后指数 = np.clip(原始指数 + 1, 1, 3)
    正规尾数 = np.zeros_like(绝对值数组, dtype=np.uint16)
    正规尾数[是否为正规数] = (
        (绝对值数组[是否为正规数] / (2.0 ** 原始指数) - 1.0) * 8192
    ).astype(np.uint16)
    正规尾数 = np.clip(正规尾数, 0, 8191)
    指数字段 = np.zeros_like(绝对值数组, dtype=np.uint16)
    指数字段[是否为正规数] = 偏置后指数
    编码结果 = 符号位 | (指数字段.astype(np.uint16) << 13) | \
              np.where(是否为次正规数, 次正规尾数, 正规尾数)
    编码结果[是否为零] = 0
    return 编码结果.astype(np.uint16)

def F16_S1E2M13解码F32(编码数组): #Qwen3-Max编写
    编码数组 = np.asarray(编码数组, dtype=np.uint16)
    符号位 = (编码数组 >> 15) & 0x1
    指数字段 = (编码数组 >> 13) & 0x3
    尾数部分 = 编码数组 & 0x1FFF
    解码值 = np.zeros_like(编码数组, dtype=np.float32)
    是否为次正规数 = 指数字段 == 0
    解码值[是否为次正规数] = 尾数部分[是否为次正规数].astype(np.float32) * (2.0 ** -13)
    是否为正规数 = 指数字段 > 0
    无偏指数 = 指数字段[是否为正规数].astype(np.int32) - 1
    解码值[是否为正规数] = (1.0 + 尾数部分[是否为正规数] / 8192.0) * (2.0 ** 无偏指数)
    解码值[符号位 == 1] *= -1.0
    return (解码值 * 5.0).astype(np.float32)
